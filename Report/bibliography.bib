% Encoding: UTF-8
@Book{WSPA,
author    = {Sanjiva Weerawarana and Francisco Curbera and Frank Leymann and Tony Storey and Donald F. Ferguson},
title     = {Web Services Platform Architecture : SOAP, WSDL, WS-Policy, WS-Addressing, WS-BPEL, WS-Reliable Messaging, and More},
year      = {2005},
publisher = {Prentice Hall PTR},
isbn      = {0131488740},
doi       = {10.1.1/jpb001}
}


@inbook{Lamport1979how,
author = {Lamport, Leslie},
year = {1979},
month = {10},
title = {How to make a multiprocessor computer that correctly executes multiprocess programs},
isbn = {9781450372701},
doi = {10.1145/3335772.3335935}
}



@article{Linearizability,
author = {Herlihy, Maurice and Wing, Jeannette},
year = {1990},
month = {07},
pages = {463-},
title = {Linearizability: A Correctness Condition for Concurrent Objects},
volume = {12},
journal = {ACM Transactions on Programming Languages and Systems},
doi = {10.1145/78969.78972}
}


@misc{li2021coo,
      title={Coo: Rethink Data Anomalies In Databases}, 
      author={Haixiang Li and Xiaoyan Li and Yuxing Chen and Yuean Zhu and Xiaoyong Du and Wei Lu and Chang Liu and Anqun Pan},
      year={2021},
      eprint={2109.06485},
      archivePrefix={arXiv},
      primaryClass={cs.DB}
}



@article{ConsistencyinNonTransactionalDistributedStorageSystems,
author = {Viotti, Paolo and Vukoli\'{c}, Marko},
title = {Consistency in Non-Transactional Distributed Storage Systems},
year = {2016},
issue_date = {March 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {1},
issn = {0360-0300},
url = {https://doi.org/10.1145/2926965},
doi = {10.1145/2926965},
abstract = {Over the years, different meanings have been associated with the word consistency in the distributed systems community. While in the ’80s “consistency” typically meant strong consistency, later defined also as linearizability, in recent years, with the advent of highly available and scalable systems, the notion of “consistency” has been at the same time both weakened and blurred.In this article, we aim to fill the void in the literature by providing a structured and comprehensive overview of different consistency notions that appeared in distributed systems, and in particular storage systems research, in the last four decades. We overview more than 50 different consistency notions, ranging from linearizability to eventual and weak consistency, defining precisely many of these, in particular where the previous definitions were ambiguous. We further provide a partial order among different consistency predicates, ordering them by their semantic “strength,” which we believe will be useful in future research. Finally, we map the consistency semantics to different practical systems and research prototypes.The scope of this article is restricted to non-transactional semantics, that is, those that apply to single storage object operations. As such, our article complements the existing surveys done in the context of transactional, database consistency semantics.},
journal = {ACM Comput. Surv.},
month = {jun},
articleno = {19},
numpages = {34},
keywords = {Consistency, distributed storage}
}


@TECHREPORT{Adya99weakconsistency,
author = {Atul Adya},
title = {Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions},
institution = {},
year = {1999}
}


@inproceedings{CrooksPuAlvisiClement,
author = {Crooks, Natacha and Pu, Youer and Alvisi, Lorenzo and Clement, Allen},
year = {2017},
month = {07},
pages = {73-82},
title = {Seeing is Believing: A Client-Centric Specification of Database Isolation},
isbn = {978-1-4503-4992-5},
doi = {10.1145/3087801.3087802}
}


@dataset{CeroneBernardiGotsman,
author = {Cerone, Andrea and Bernardi, Giovanni and Gotsman, Alexey},
year = {2015},
month = {09},
pages = {},
title = {A Framework for Transactional Consistency Models with Atomic Visibility (Slides)}
}


@inproceedings{Choasmonkey,
author = {Chang, Michael Alan and Tschaen, Bredan and Benson, Theophilus and Vanbever, Laurent},
title = {Chaos Monkey: Increasing SDN Reliability through Systematic Network Destruction},
year = {2015},
isbn = {9781450335423},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2785956.2790038},
doi = {10.1145/2785956.2790038},
booktitle = {Proceedings of the 2015 ACM Conference on Special Interest Group on Data Communication},
pages = {371–372},
numpages = {2},
location = {London, United Kingdom},
series = {SIGCOMM '15}
}

@article{10.1145/2829988.2790038,
author = {Chang, Michael Alan and Tschaen, Bredan and Benson, Theophilus and Vanbever, Laurent},
title = {Chaos Monkey: Increasing SDN Reliability through Systematic Network Destruction},
year = {2015},
issue_date = {October 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {4},
issn = {0146-4833},
url = {https://doi.org/10.1145/2829988.2790038},
doi = {10.1145/2829988.2790038},
journal = {SIGCOMM Comput. Commun. Rev.},
month = aug,
pages = {371–372},
numpages = {2}
}





@inproceedings{Berensonetal,
author = {Berenson, Hal and Bernstein, Phil and Gray, Jim and Melton, Jim and O'Neil, Elizabeth and O'Neil, Patrick},
title = {A Critique of ANSI SQL Isolation Levels},
year = {1995},
isbn = {0897917316},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/223784.223785},
doi = {10.1145/223784.223785},
abstract = {ANSI SQL-92 [MS, ANSI] defines Isolation Levels in terms of phenomena: Dirty Reads,
Non-Repeatable Reads, and Phantoms. This paper shows that these phenomena and the
ANSI SQL definitions fail to properly characterize several popular isolation levels,
including the standard locking implementations of the levels covered. Ambiguity in
the statement of the phenomena is investigated and a more formal statement is arrived
at; in addition new phenomena that better characterize isolation types are introduced.
Finally, an important multiversion isolation type, called Snapshot Isolation, is defined.},
booktitle = {Proceedings of the 1995 ACM SIGMOD International Conference on Management of Data},
pages = {1–10},
numpages = {10},
location = {San Jose, California, USA},
series = {SIGMOD '95}
}


@book{DBMSbook,
author = {Ramakrishnan, Raghu and Gehrke, Johannes},
title = {Database Management Systems},
year = {2000},
isbn = {0072440422},
publisher = {McGraw-Hill, Inc.},
address = {USA},
edition = {2nd}
}


@Misc{jepsonio,
author = {{Kyle Kingsbury}},
title =  {Jepsen io Website},
year =   {2016},
url =    {https://jepsen.io/}
}

@Misc{aphyrpostgres,
author = {{Kyle Kingsbury}},
title =  {Aphyr, Jepsen test postgres.},
year =   {2013},
url =    {https://aphyr.com/posts/282-jepsen-postgres}
}

@Misc{aphyrelasticsearch,
author = {{Kyle Kingsbury}},
title =  {Aphyr, Jepsen test Elasticsearch.},
year =   {2014},
url =    {https://aphyr.com/posts/317-jepsen-elasticsearch}
}

@Misc{jepsenhazelcast,
author = {{Kyle Kingsbury}},
title =  {Aphyr, Jepsen test hazelcast.},
year =   {2017},
url =    {https://hazelcast.com/blog/jepsen-analysis-hazelcast-3-8-3/}
}

@Misc{jepsenscylla,
author = {{Kyle Kingsbury}},
title =  {Aphyr, Jepsen test scylla.},
year =   {2020},
url =    {https://jepsen.io/analyses/scylla-4.2-rc3}
}

@Misc{jepsencassandra,
author = {{Kyle Kingsbury}},
title =  {Jepsen: Cassandra},
year =   {2013},
url =    {https://aphyr.com/posts/294-call-me-maybe-cassandra}
}

@Misc{jepsenpostgresql,
author = {{Kyle Kingsbury}},
title =  {Jepsen: postgresql},
year =   {2020},
url =    {https://jepsen.io/analyses/postgresql-12.3}
}

@Misc{jepsenmongodb243,
author = {{Kyle Kingsbury}},
title =  {Jepsen: Mongodb 2.4.3},
year =   {2013},
url =    {https://aphyr.com/posts/284-call-me-maybe-mongodb}
}

@Misc{jepsenmongodb267,
author = {{Kyle Kingsbury}},
title =  {Jepsen: Mongodb 2.6.7},
year =   {2015},
url =    {https://aphyr.com/posts/322-call-me-maybe-mongodb-stale-reads}
}

@Misc{jepsenmongodb340,
author = {{Kyle Kingsbury}},
title =  {Jepsen: Mongodb 3.4.0},
year =   {2017},
url =    {https://jepsen.io/analyses/mongodb-3-4-0-rc3}
}

@Misc{breakingchangesdotnet,
author = {{Microsoft}},
title =  {Microsoft documentation: Breaking changes},
url =    {https://docs.microsoft.com/en-us/dotnet/core/compatibility/}
}





@article{Cassandra,
author = {Lakshman, Avinash and Malik, Prashant},
title = {Cassandra: A Decentralized Structured Storage System},
year = {2010},
issue_date = {April 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {44},
number = {2},
issn = {0163-5980},
url = {https://doi.org/10.1145/1773912.1773922},
doi = {10.1145/1773912.1773922},
abstract = {Cassandra is a distributed storage system for managing very large amounts of structured data spread out across many commodity servers, while providing highly available service with no single point of failure. Cassandra aims to run on top of an infrastructure of hundreds of nodes (possibly spread across different data centers). At this scale, small and large components fail continuously. The way Cassandra manages the persistent state in the face of these failures drives the reliability and scalability of the software systems relying on this service. While in many ways Cassandra resembles a database and shares many design and implementation strategies therewith, Cassandra does not support a full relational data model; instead, it provides clients with a simple data model that supports dynamic control over data layout and format. Cassandra system was designed to run on cheap commodity hardware and handle high write throughput while not sacrificing read efficiency.},
journal = {SIGOPS Oper. Syst. Rev.},
month = {apr},
pages = {35–40},
numpages = {6}
}


@article{AGENDA,
author = {Deng, Yuetang and Frankl, Phyllis and Chays, David},
year = {2003},
month = {01},
pages = {},
title = {Testing database transaction consistency}
}

@article{HISTEX,
author = {Dimitrios Liarokapis},
year = {2002},
month = {01},
pages = {},
email = {dimitris@cs.umb.edu},
url = {https://www.vldb.org/conf/2002/S34P10.pdf},
organization = {University of Massachusetts Boston },
title = {Testing Isolation Levelsof Relational Database Management Systems}
}

@article{elle,
author = {Kingsbury, Kyle and Alvaro, Peter},
title = {Elle: Inferring Isolation Anomalies from Experimental Observations},
year = {2020},
issue_date = {November 2020},
publisher = {VLDB Endowment},
volume = {14},
number = {3},
issn = {2150-8097},
url = {https://doi.org/10.14778/3430915.3430918},
doi = {10.14778/3430915.3430918},
abstract = {Users who care about their data store it in databases, which (at least in principle) guarantee some form of transactional isolation. However, experience shows that many databases do not provide the isolation guarantees they claim. With the recent proliferation of new distributed databases, demand has grown for checkers that can, by generating client workloads and injecting faults, produce anomalies that witness a violation of a stated guarantee. An ideal checker would be sound (no false positives), efficient (polynomial in history length and concurrency), effective (finding violations in real databases), general (analyzing many patterns of transactions), and informative (justifying the presence of an anomaly with understandable counterexamples). Sadly, we are aware of no checkers that satisfy these goals.We present Elle: a novel checker which infers an Adya-style dependency graph between client-observed transactions. It does so by carefully selecting database objects and operations when generating histories, so as to ensure that the results of database reads reveal information about their version history. Elle can detect every anomaly in Adya et al's formalism (except for predicates), discriminate between them, and provide concise explanations of each. This paper makes the following contributions: we present Elle, demonstrate its soundness over specific datatypes, measure its efficiency against the current state of the art, and give evidence of its effectiveness via a case study of four real databases.},
journal = {Proc. VLDB Endow.},
month = {nov},
pages = {268–280},
numpages = {13}
}
  
@Misc{SF_RC_Transactions,
author = {{Microsoft doc}},
title =  {Transactions and lock modes in Azure Service Fabric Reliable Collections},
year =   {2017},
month = {5},
url =    {https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-reliable-collections-transactions-locks}
}




@article{HighlyAvailableTransactionsVirtuesandLimitations,
author = {Bailis, Peter and Davidson, Aaron and Fekete, Alan and Ghodsi, Ali and Hellerstein, Joseph M. and Stoica, Ion},
title = {Highly Available Transactions: Virtues and Limitations},
year = {2013},
month = {10},
publisher = {VLDB Endowment},
volume = {7},
number = {3},
issn = {2150-8097},
url = {https://doi.org/10.14778/2732232.2732237},
doi = {10.14778/2732232.2732237},
abstract = {To minimize network latency and remain online during server failures and network partitions,
many modern distributed data storage systems eschew transactional functionality, which
provides strong semantic guarantees for groups of multiple operations over multiple
data items. In this work, we consider the problem of providing Highly Available Transactions
(HATs): transactional guarantees that do not suffer unavailability during system partitions
or incur high network latency. We introduce a taxonomy of highly available systems
and analyze existing ACID isolation and distributed data consistency guarantees to
identify which can and cannot be achieved in HAT systems. This unifies the literature
on weak transactional isolation, replica consistency, and highly available systems.
We analytically and experimentally quantify the availability and performance benefits
of HATs---often two to three orders of magnitude over wide-area networks---and discuss
their necessary semantic compromises.},
journal = {Proc. VLDB Endow.},
month = {5},
pages = {181–192},
numpages = {12}
}


@article{Herlihy1990Linearizability,
author = {Herlihy, Maurice P. and Wing, Jeannette M.},
title = {Linearizability: A Correctness Condition for Concurrent Objects},
year = {1990},
issue_date = {July 1990},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {12},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/78969.78972},
doi = {10.1145/78969.78972},
abstract = {A concurrent object is a data object shared by concurrent processes. Linearizability
is a correctness condition for concurrent objects that exploits the semantics of abstract
data types. It permits a high degree of concurrency, yet it permits programmers to
specify and reason about concurrent objects using known techniques from the sequential
domain. Linearizability provides the illusion that each operation applied by concurrent
processes takes effect instantaneously at some point between its invocation and its
response, implying that the meaning of a concurrent object's operations can be given
by pre- and post-conditions. This paper defines linearizability, compares it to other
correctness conditions, presents and demonstrates a method for proving the correctness
of implementations, and shows how to reason about concurrent objects, given they are
linearizable.},
journal = {ACM Trans. Program. Lang. Syst.},
month = jul,
pages = {463–492},
numpages = {30}
}


@Misc{Knossos,
author = {{Kyle Kingsbury}},
title =  {knosso git repo},
url =    {https://github.com/jepsen-io/knosso}
}



@Misc{servicefabriccli,
    author = {{Microsoft}},
    title =  {Azure Service Fabric documentation},
    url =    {https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cl}
}


@Misc{servicefabricguide,
    author = {{Microsoft}},
    title =  {Azure Service Fabric documentation tutorial},
    url =    {https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-tutorial-deploy-app-to-party-cluster}
}

@Misc{servicefabricguidelines,
    author = {{Microsoft}},
    title =  {Azure Service Fabric, reliable collections documentation},
    url =    {https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines}
}


@Misc{wikihttpstatuscodes,
    author = {{Wikipedia}},
    title =  {Http Status codes},
    url =    {https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}
}




@Standard{ansisql1999,
author = {{ISO/IEC}},
title =  {ISO/IEC 9075-2:1999 (E)},
issue_date =   {September 1999},
url =    {http://web.cecs.pdx.edu/~len/sql1999.pdf}
}



@ARTICLE{Haerder83principlesof,
author = {Theo Haerder and Andreas Reuter},
title = {Principles of Transaction-Oriented Database Recovery},
journal = {ACM Computing Surveys},
year = {1983},
volume = {15},
pages = {287--317}
}


@REPORT{CSL-TR-95-685,
author = {Kourosh Gharachorloo},
title = {MEMORY CONSISTENCY MODELS FOR SHARED-MEMORY MULTIPROCESSORS},
publisher = {DARPA contract N00039-91-C-0138},
organization={CSR, Stanford University},
year = {1995},
url = {http://i.stanford.edu/pub/cstr/reports/csl/tr/95/685/CSL-TR-95-685.pdf}
}

@article{CAP,
author = {Gilbert, Seth and Lynch, Nancy},
title = {Brewer's Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services},
year = {2002},
issue_date = {June 2002},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {33},
number = {2},
issn = {0163-5700},
url = {https://doi.org/10.1145/564585.564601},
doi = {10.1145/564585.564601},
abstract = {When designing distributed web services, there are three properties that are commonly
desired: consistency, availability, and partition tolerance. It is impossible to achieve
all three. In this note, we prove this conjecture in the asynchronous network model,
and then discuss solutions to this dilemma in the partially synchronous model.},
journal = {SIGACT News},
month = jun,
pages = {51–59},
numpages = {9}
}

@inproceedings{brewer2000towards,
title={Towards robust distributed systems},
author={Brewer, Eric A},
year={2000},
url = {https://sites.cs.ucsb.edu/~rich/class/cs293b-cloud/papers/Brewer_podc_keynote_2000.pdf},
organization={UC Berkeley}
}

@Article{lamport1993how,
author = {Lamport, Leslie},
title = {How to Make a Correct Multiprocess Program Execute Correctly on a Multiprocessor},
year = {1993},
month = {2},
abstract = {This paper was inspired by Kourosh Gharachorloo's thesis. The problem he addressed was how to execute a multiprocess program on a computer whose memory did not provide sequential consistency (see [35]), but instead required explicit synchronization operations (such as Alpha's memory barrier instruction). He presented a method for deducing what synchronization operations had to be added to a program. I realized that, if one proved the correctness of an algorithm using the two-arrow formalism of [33], the proof would tell you what synchronization operations were necessary. This paper explains how.},
url = {https://www.microsoft.com/en-us/research/publication/make-correct-multiprocess-program-execute-correctly-multiprocessor/},
pages = {779-782},
journal = {IEEE Transactions on Computers  SRC Research Report 96},
volume = {46},
edition = {Also appeared as SRC Research Report 96},
number = {7},
}

@inproceedings{SFpaper,
author = {Kakivaya, Gopal and Xun, Lu and Hasha, Richard and Ahsan, Shegufta Bakht and Pfleiger, Todd and Sinha, Rishi and Gupta, Anurag and Tarta, Mihail and Fussell, Mark and Modi, Vipul and Mohsin, Mansoor and Kong, Ray and Ahuja, Anmol and Platon, Oana and Wun, Alex and Snider, Matthew and Daniel, Chacko and Mastrian, Dan and Li, Yang and Rao, Aprameya and Kidambi, Vaishnav and Wang, Randy and Ram, Abhishek and Shivaprakash, Sumukh and Nair, Rajeet and Warwick, Alan and Narasimman, Bharat S. and Lin, Meng and Chen, Jeffrey and Mhatre, Abhay Balkrishna and Subbarayalu, Preetha and Coskun, Mert and Gupta, Indranil},
title = {Service Fabric: A Distributed Platform for Building Microservices in the Cloud},
year = {2018},
isbn = {9781450355841},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3190508.3190546},
doi = {10.1145/3190508.3190546},
abstract = {We describe Service Fabric (SF), Microsoft's distributed platform for building, running,
and maintaining microservice applications in the cloud. SF has been running in production
for 10+ years, powering many critical services at Microsoft. This paper outlines key
design philosophies in SF. We then adopt a bottom-up approach to describe low-level
components in its architecture, focusing on modular use and support for strong semantics
like fault-tolerance and consistency within each component of SF. We discuss lessons
learned, and present experimental results from production data.},
booktitle = {Proceedings of the Thirteenth EuroSys Conference},
articleno = {33},
numpages = {15},
keywords = {failure detection, microservices, distributed systems, production systems, scheduling},
location = {Porto, Portugal},
series = {EuroSys '18}
}





%G. Lowe. Testing and Verifying Concurrent Objects.
%Concurrency and Computation: Practice and
%Experience, 29(4), 2017
%
%J. M. Wing and C. Gong. Testing and Verifying
%Concurrent Objects. Journal of Parallel and
%Distributed Computing, 17(1-2), 1993.
%
%P. B. Gibbons and E. Korach. Testing shared
%memories. SIAM Journal on Computing, 26(4), 1997
%
%S. Burckhardt, C. Dern, M. Musuvathi, and R. Tan.
%Line-up: A Complete and Automatic Linearizability
%Checker. PLDI ’10, 2010.
